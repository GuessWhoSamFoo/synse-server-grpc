syntax = "proto3";

package synse;


service InternalApi {

    // Read from the specified device(s).
    rpc Read(ReadRequest) returns (stream ReadResponse) {}

    // Write to the specified device(s).
    rpc Write(WriteRequest) returns (Transactions) {}

    // Get the metainformation from the background process that describes
    // all of the available devices which that process owns
    rpc Metainfo(MetainfoRequest) returns (stream MetainfoResponse) {}

    // Check on the state of a write transaction.
    rpc TransactionCheck(TransactionId) returns (WriteResponse) {}

}


// -------------------------------
// Request Messages
// -------------------------------


// Read
// ~~~~
// the read request message contains the uuid of the device that
// we desire to read. the uuid of the device should be generated
// by the owning background process and should be returned to the
// synse application in the MetainfoResponse, which Synse will
// cache and use as a lookup table for routing requests.
message ReadRequest {

    // the id of the device to read. this is generated by the plugin
    // and returned via the `Metainfo` request under the `uid` field.
    string device = 1;

    // the board identifier which the device belongs to.
    string board = 2;

    // the rack identifier which the board belongs to.
    string rack = 3;
}


// Write
// ~~~~~
// the write request message contains the uuid of the device that
// we desire to write to, as well as a repeated string (e.g. a
// list of strings in Python) which makes up the data that we
// which to write to that device.
message WriteRequest {

    // the id of the device to write to. this is generated by the
    // plugin and returned via the `Metainfo` request under the
    // `uid` field.
    string device = 1;

    // the board identifier which the device belongs to.
    string board = 2;

    // the rack identifier which the board belongs to.
    string rack = 3;

    // the data to write. a given synse-server write request could
    // actually be a composite of writes. for example, one can turn
    // an LED on and change its color simultaneously via the Synse
    // JSON API. each `WriteData` will get its own transaction id.
    repeated WriteData data = 4;
}


// Metainfo
// ~~~~~~~~
// the metainfo request message contains a field for rack and board,
// but neither are required. if specified, the response will contain
// only information relating to the rack/board filter applied. if
// they are left unspecified, the response will contain the entirety
// of the metainfo scan information.
message MetainfoRequest {

    // the rack filter for the meta information response.
    string rack = 1;

    // the board filter for the meta information response.
    string board = 2;
}


// TransactionCheck
// ~~~~~~~~~~~~~~~~
// the transaction id gives identity to a single 'write' action. since
// device writes are handled asynchronously, the background process
// returns the transaction id when a write is registered, which the
// caller can later pass back to `TransactionCheck` to get the status
// of that write.
message TransactionId {

    // the id of a write transaction. this is returned by the write
    // commands `Transactions` response.
    string id = 1;

}


// -------------------------------
// Response Messages
// -------------------------------


// Read
// ~~~~
// the read response provides the timestamp at which the reading was
// taken, the type of the reading (e.g. temperature, humidity, led
// state, etc.), and the value of that reading. read responses are
// returned to the client as a stream, so a single device can return
// multiple readings. (e.g. a humidity sensor can return a %humidity
// reading and a temperature reading).
message ReadResponse {

    // the time which the reading was taken.
    string timestamp = 1;

    // the type of reading.
    string type = 2;

    // the value of the reading.
    string value = 3;
}


// Write
// ~~~~~
// the transactions message specifies the asynchronous transactions for
// each of the given write actions. each transaction identifies a single
// write action with a unique transaction id and context to help identify
// which transaction that id is associated with. the transaction id can
// later be passed back to `TransactionCheck` to get the status of that
// write.
message Transactions {

    // a map where the key is the transaction id for a given `WriteData`
    // message that has been processed, and the value is that same
    // `WriteData` message. the `WriteData` message is passed back in
    // order to provide some context and make identifying transactions
    // possible. the number of entries in the transactions map corresponds
    // to the number of `WriteData` recieved in a `WriteRequest`.
    map<string, WriteData> transactions = 1;
}


// Metainfo
// ~~~~~~~~
// the metainfo response represents a single device that is owned by
// the process. metainfo responses are returned to the client as a stream
// so a background process can support any number of devices. the response
// itself contains a timestamp for when the response was generated, an
// for the device, and all other meta-information we have pertaining to
// that device. the caller, Synse, will cache this information and use it
// to route requests to the appropriate device as well as provide responses
// for scan and info requests.
message MetainfoResponse {

    // the time at which the metainfo was gathered.
    string timestamp = 1;

    // the unique id for the device this response represents.
    string uid = 2;

    // the device type.
    string type = 3;

    // the device model.
    string model = 4;

    // the device manufacturer.
    string manufacturer = 5;

    // the protocol that the device is configured to use.
    string protocol = 6;

    // any additional information specified for the device.
    string info = 7;

    // any comment specified for the device.
    string comment = 8;

    // the location of the device, as specified by rack and board
    // identifiers.
    MetaLocation location = 9;

    // the reading output of the device. this specifies all of the
    // outputs a device will generate when read. most devices will have
    // a single output, but some devices (e.g. a humidity sensor) could
    // return multiple data points from a single reading. (e.g.
    // temperature and humidity).
    repeated MetaOutput output = 10;
}


// TransactionCheck
// ~~~~~~~~~~~~~~~~
// the response for a transaction check command gives the status of the
// transaction. transactions correspond to write requests. since writes
// are performed asynchronously, the transaction id is used to track the
// progress of that transaction.
message WriteResponse {

    enum WriteStatus {
        UNKNOWN = 0;
        PENDING = 1;
        WRITING = 2;
        DONE = 3;
    }

    enum WriteState {
        OK = 0;
        ERROR = 1;
    }

    // the time at which the write transaction was created.
    string created = 1;

    // the time at which the write transaction was last updated (either
    // for an update to state or status).
    string updated = 2;

    // the status of the transaction. this describes what stage of
    // processing the transaction is at.
    WriteStatus status = 3;

    // the state of the transaction. this describes the so called "health"
    // of the transaction.
    WriteState state = 4;

    // the message field will be used to specify any context information
    // when the state is in ERROR. if the state is OK, this field will
    // remain empty.
    string message = 5;
}


// -------------------------------
// Message Components
// -------------------------------


// Specifies the data that gets written on a `WriteRequest`. This is a
// composite of raw bytes and an action string. Both of the fields can
// be specified, or only one of them. In cases where no action is supplied,
// the plugin can take the raw data as raw bytes to write to the device.
// There may be cases when only an action is supplied, such as "on" for
// turning an LED on (which the plugin can then interpret for its protocol).
// Both can be specified, such as changing the color of an LED where the
// raw bytes can specify the color itself and the action could be "color",
// differentiating it from a write to LED blink state, etc.
message WriteData {

    // raw bytes to send to the plugin for writing.
    repeated bytes raw = 1;

    // a (well-known) action identifier.
    string action = 2;
}


// the unit specification for a reading output.
message MetaOutputUnit {

    // the full name of the unit, e.g. "degrees celsius".
    string name = 1;

    // the symbol for the unit, e.g. "C".
    string symbol = 2;
}


// the value range specification for a reading output.
message MetaOutputRange {

    // the minimum allowable value for a numeric reading.
    int32 min = 1;

    // the maximum allowable value for a numeric reading.
    int32 max = 2;
}

// the specification for one of a device's reading outputs.
message MetaOutput {

    // the type of the reading output (e.g. 'temperature',
    // 'humidity', etc).
    string type = 1;

    // the data type of the output (e.g. int, string, bool).
    string data_type = 2;

    // the decimal precision of the output. if the output is
    // non-numeric, this can be left unspecified and will be
    // ignored.
    int32 precision = 3;

    // the unit of measure for the reading.
    MetaOutputUnit unit = 4;

    // the acceptable range of values for the reading.
    MetaOutputRange range = 5;
}

// the location specification for a device.
message MetaLocation {

    // the rack which the device belongs to.
    string rack = 1;

    // the board which the device belongs to.
    string board = 2;
}
